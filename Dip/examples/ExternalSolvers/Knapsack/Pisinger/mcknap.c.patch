66d65
< #include <values.h>
69d67
< #include <values.h>
71c69
< #include <malloc.h>
---
> #include <memory.h>
240a239
> #ifndef _MSC_VER
253c252
<   double t1, t2;
---
>   double t1;
256c255
<   fprintf(trace, "%.2lf", t1);
---
>   fprintf(trace, "%.2f", t1);
267c266
<   *time = t1 * 1000;
---
>   *time = (long)(t1 * 1000);
269c268
< 
---
> #endif
279,280c278,279
<   if (trace == NULL) printf("trace not openn\n");
<   tot1 = 0; 
---
>   if (trace == NULL) DEBUG(printf("trace not openn\n"));
>   tot1 = 0;
297c296
<     memcpy(t, lines, 2*traceniveau);
---
>     memcpy(t, lines, (size_t)(2*traceniveau));
301c300
<     if (traceconsole) printf("%s\n", t);
---
>     if (traceconsole) DEBUG(printf("%s\n", t));
308c307
< void vis(int level, char *s, ...)
---
> void vis(int level, const char *s, ...)
315c314
<     memcpy(t, lines, 2*traceniveau);
---
>     memcpy(t, lines, (size_t)(2*traceniveau));
318c317
<       printf("%s", t);
---
>       DEBUG(printf("%s", t));
322c321
<       if (traceconsole) printf("%s", t);
---
>       if (traceconsole) DEBUG(printf("%s", t));
337c336
<     memcpy(t, lines, 2*traceniveau);
---
>     memcpy(t, lines, (size_t)(2*traceniveau));
341c340
<     if (traceconsole) printf("%s\n", t);
---
>     if (traceconsole) DEBUG(printf("%s\n", t));
349,351c348
<   int i;
< 
<   fflush(trace); 
---
>   fflush(trace);
360c357
< void error(char *str, ...)
---
> void error(const char *str, ...)
366c363
<   printf("\n");
---
>   DEBUG(printf("\n"));
370c367
<   printf("THE PROGRAM IS TERMINATED !!!\n\n");
---
>   DEBUG(printf("THE PROGRAM IS TERMINATED !!!\n\n"));
380a378
> #ifndef _MSC_VER
393c391
<     if (first) printf("sleeping\n");
---
>     if (first) DEBUG(printf("sleeping\n"));
397c395
< 
---
> #endif
408c406
<   m = malloc(size);
---
>   m = malloc((size_t)size);
469c467
< 
---
> #endif
479,480c477,481
<   vis(1,"ITEMSET: size %d choice (%hd,%hd)\n",
<       d->size, d->f.psum, d->f.wsum);
---
>   /*vis(1,"ITEMSET: size %d choice (%hd,%hd)\n",
>     d->size, d->f.psum, d->f.wsum);*/
>   fflush(stdout);
>   vis(1,"ITEMSET: size %d choice \n",
>       d->size);
485d485
< }
486a487,494
>   DEBUG(printf("ITEMSET: size %d choice \n",
> 	 d->size));
>   im = d->lset;
>   for (i = d->fset; i <= im; i++)
>     DEBUG(printf("  (i:%d,j:%d)  (p:%d,w:%d)\n",
> 		 i->i, i->j,
> 		 i->psum, i->wsum));
> }
487a496
> #if 0
523c532
<     redupct  = (reduitems == 0 ? 
---
>     redupct  = (reduitems == 0 ?
574c583
< 
---
> #endif
598d606
< }
599a608,611
>   /* MVG */
>   visitems(j);
> }
> #endif
635c647
< 
---
> #endif
650c662
< 
---
> #endif
657c669,670
<                   ordstack *a, ordstack *b, stype *c, stype *z, stype *ub)
---
>                   ordstack *a, ordstack *b, stype *c, stype *z, stype *ub,
> 		  stype *obj)
668,671c681,684
<   vis(1,"definesolution size %d, (%ld,%ld) vect %ld vmax %ld\n",
<       optsol.size, psum, wsum, vect, optsol.vmax);
<   vis(1,"definesolution maengde a: %d, b: %d\n",
<      optsol.a - a->first, b->last - optsol.b);
---
>   DEBUG(printf("definesolution size %d, (%g,%g) vect %ld vmax %ld\n",
>                optsol.size, psum, wsum, vect, optsol.vmax));
>   DEBUG(printf("definesolution maengde a: %ld, b: %ld\n",
>                 optsol.a - a->first, b->last - optsol.b));
684,685c697,698
<     vis(2,"choice no %ld of %hd is (%hd,%hd)\n",
< 	rem, s->size, jc->psum, jc->wsum);
---
>     DEBUG(printf("choice no %ld of %hd is (%hd,%hd)\n",
>                  rem, s->size, jc->psum, jc->wsum));
692c705
<   vis(2,"FINAL sum %ld,%ld, break %ld,%ld\n", psum, wsum, fixp, fixw);
---
>   DEBUG(printf("FINAL sum %g,%g, break %g,%g\n", psum, wsum, fixp, fixw));
694c707,710
<   if (al->welldef) return TRUE;
---
>   if (al->welldef){
>     *obj = psum;
>     return TRUE;
>   }
739a756
> #ifndef _MSC_VER
744c761
<   itype *p, *w;
---
>   itype *p = NULL, *w = NULL;
751,752c768,769
<     p = palloc(n * (long) sizeof(itype));
<     w = palloc(n * (long) sizeof(itype));
---
>     p = (itype*) palloc(n * (long) sizeof(itype));
>     w = (itype*) palloc(n * (long) sizeof(itype));
757,758c774,775
<     qsort(p, n, sizeof(itype), (funcptr) icmp);
<     qsort(w, n, sizeof(itype), (funcptr) icmp);
---
>     qsort(p, (size_t)n, sizeof(itype), (funcptr) icmp);
>     qsort(w, (size_t)n, sizeof(itype), (funcptr) icmp);
794a812,814
> 
>   /* MVG */
>   visitems(j);
805c825
<   itemset *j, *jm, *k;
---
>   itemset *j, *jm;
811c831
<   h->fset  = palloc(h->size * (long) sizeof(itemset));
---
>   h->fset  = (itemset*) palloc(h->size * (long) sizeof(itemset));
818c838
<     j->fset = palloc(size * (long) sizeof(itemrec));
---
>     j->fset = (itemrec*) palloc(size * (long) sizeof(itemrec));
838c858
<   vis(2,"SETS %hd, MINW %ld, MAXW %ld, C %ld\n",
---
>   vis(2,"SETS %hd, MINW %g, MAXW %g, C %g\n",
842c862
< 
---
> #endif
860c880
<     *k1 = palloc((d+1) * (long) sizeof(partvect));/* 1 extra is used below */
---
>     *k1 = (partvect*) palloc((d+1) * (long) sizeof(partvect));/* 1 extra is used below */
881c901
<     *k1 = palloc(size * (long) sizeof(partvect));
---
>     *k1 = (partvect*) palloc(size * (long) sizeof(partvect));
905a926,928
> 
>   /* MVG */
>   visitems(j);
917d939
<   vtype vmax;
925c947
<   vis(2,"MULTIPLY (%ld*%ld) = %ld -> %ld\n",
---
>   vis(2,"MULTIPLY (%g*%g) = %g -> %g\n",
971c993
<   vis(2,"Z=%ld, reduceset %3d -> %3d  s(%hd,%hd) t(%hd,%hd)\n",
---
>   vis(2,"Z=%g, reduceset %3d -> %3d  s(%hd,%hd) t(%hd,%hd)\n",
986c1008
<   stype z, ub, psum1, wsum1;
---
>   stype z, psum1, wsum1;
1001c1023
<     if (DET(psum1-z,wsum1-c,pb,wb) >= 0) { i++; } 
---
>     if (DET(psum1-z,wsum1-c,pb,wb) >= 0) { i++; }
1004c1026
<   vis(2,"Z=%ld, reitem %3d -> %3d\n",
---
>   vis(2,"Z=%g, reitem %3d -> %3d\n",
1031c1053,1055
<       if (i->wsum <  f->wsum) f = i;
---
>        /*printf("  i->wsum=%d i->psum=%d\n", i->wsum, i->psum);*/
>       if (i->wsum <  f->wsum)
>         f = i;
1033c1057,1058
< 	if ((i->psum > l->psum) || (i->wsum < l->wsum)) l = i;
---
> 	if ((i->psum > l->psum) || (i->wsum < l->wsum))
>           l = i;
1036,1037c1061,1067
<     j->f = *f; minw += f->wsum;
<     j->l = *l; maxw += l->wsum;
---
>     j->f = *f;
>     minw += f->wsum;
>     j->l = *l;
> 
>     maxw += l->wsum;
>     /*printf("l->wsum: %d l->psum: %d maxw: %d\n",
>       l->wsum, l->psum, maxw);*/
1055c1085,1086
<   vis(2,"now %hd fix (%ld,%ld) kill %hd\n", head->size, *fixp, *fixw, kill);
---
>   DEBUG(printf("now %hd fix (%g,%g) kill %ld\n",
>                head->size, *fixp, *fixw, kill));
1076d1106
<   itype dp, dw;
1086c1116
<   qsort(&a, d, sizeof(ordrec), (funcptr) lamless);
---
>   qsort(&a, (size_t)d, sizeof(ordrec), (funcptr) lamless);
1099c1129
<   register itemrec *i, *no;
---
>   register itemrec *i, *no = NULL;
1130d1159
< }
1131a1161,1164
>   /* MVG */
>   visitems(j);
> }
> #endif
1143c1176
<   itype p1, w1, pm, wm;
---
>   itype p1, wm;
1194c1227
<   itemrec *i1, *im, *choice;
---
>   itemrec *i1, *im;
1228c1261
< void partition(allinfo *al, isetset *head, stype c,
---
> int partition(allinfo *al, isetset *head, stype c,
1237c1270,1271
<   if ((minwsum > c) || (maxwsum <= c)) return;
---
>   DEBUG(printf("\nminwsum: %g, maxwsum: %g, c: %g",
> 	 minwsum, maxwsum, c));
1238a1273,1282
>   /*MVG: have to deal with trivial cases separate*/
>   if(minwsum > c){
>      DEBUG(printf("\nMCKNAP_RC_INF"));
>      return MCKNAP_RC_INF;
>   }
>   if(maxwsum <= c){
>      /*DEBUG(printf("\nMCKNAP_RC_TRIVIAL_MAXSUM"));*/
>      return MCKNAP_RC_TRIVIAL_MAXSUM;
>   }
>   
1248c1292,1294
<     vis(2,"wsum %ld-%ld: c %ld\n", minwsum, maxwsum, c);
---
>     DEBUG(printf("wsum %g-%g: c %g\n", minwsum, maxwsum, c));
>     fflush(stdout);
>     vis(2,"wsum %g-%g: c %g\n", minwsum, maxwsum, c);
1259c1305
<   vis(1,"UB=%ld Z=%ld FIXED (%ld,%ld) BREAK (%hd,%hd) CAP %ld\n",
---
>   vis(1,"UB=%g Z=%g FIXED (%g,%g) BREAK (%hd,%hd) CAP %g\n",
1260a1307,1309
>   DEBUG(printf("UB=%g Z=%g FIXED (%g,%g) BREAK (%hd,%hd) CAP %g\n",
>       al->dantzig, fixp, fixp, fixw, *dp, *dw, al->capacity));
>   return MCKNAP_RC_OK;
1281c1330,1336
<   if ((psum != 0) || (wsum != 0)) error("choices not first");
---
>   if ((psum != 0) || (wsum != 0)){
>     DEBUG(printf("\npsum: %g, wsum: %g", psum, wsum));
>     error("choices not first");
>   }
> 
>   /* MVG */
>   visitems(j);
1306c1361
<   qsort(mid->fset, SIZE(mid), sizeof(itemrec), (funcptr) itemless);
---
>   qsort(mid->fset, (size_t)SIZE(mid), sizeof(itemrec), (funcptr) itemless);
1309c1364
<   k1 = palloc(mid->size * (long) sizeof(itemrec));
---
>   k1 = (itemrec*) palloc(mid->size * (long) sizeof(itemrec));
1333c1388
<   mid->fset = palloc(old->size * (long) sizeof(partvect));
---
>   mid->fset = (partvect*) palloc(old->size * (long) sizeof(partvect));
1386d1440
< }
1387a1442,1445
>   /* MVG */
>   visitems(j);
> }
> #endif
1395d1452
<   int l;
1404a1462,1464
> 
>   /* MVG */
>   visitems(j);
1451,1452c1511,1512
<   stacka->first = palloc(head->size * (long) sizeof(ordrec));
<   stackb->first = palloc(head->size * (long) sizeof(ordrec));
---
>   stacka->first = (ordrec*) palloc(head->size * (long) sizeof(ordrec));
>   stackb->first = (ordrec*) palloc(head->size * (long) sizeof(ordrec));
1478c1538
< 
---
> #ifndef _MSC_VER
1483c1543
<   stype cstar, psum, wsum, z, c, ub;
---
>   stype cstar, psum = 0, wsum = 0, z, c, ub;
1487a1548
>   stype obj = 0;
1489c1550
<   int i;
---
>   int i, stat;
1506a1568
> #ifndef _MSC_VER
1507a1570
> #endif
1511c1574,1577
<   partition(&a, &head, c, &psum, &wsum, &pb, &wb);
---
>   stat = partition(&a, &head, c, &psum, &wsum, &pb, &wb);
>   DEBUG(printf("\nc: %g, psum: %g, wsum: %g", c, psum, wsum));
>   if(stat != MCKNAP_RC_OK)
>     return;
1512a1579
> #ifndef _MSC_VER
1513a1581
> #endif
1519a1588
> #ifndef _MSC_VER
1520a1590
> #endif
1561c1631
<     optimal = definesol(&a, psum, wsum, &stacka, &stackb, &c, &z, &ub);
---
>     optimal = definesol(&a, psum, wsum, &stacka, &stackb, &c, &z, &ub, &obj);
1564c1634
<     vis(1,"TUR TIL MED c %ld, z %ld, ub %ld\n", c, z, ub);
---
>     vis(1,"TUR TIL MED c %g, z %g, ub %g\n", c, z, ub);
1570a1641
> #ifndef _MSC_VER
1571a1643
> #endif
1573c1645
<   sumdata(&a);
---
>   /*sumdata(&a);*/
1575a1648
> #endif
1576a1650,1821
> /* ======================================================================
> 				 minmcknap
>    ====================================================================== */
> 
> int minmcknapSolve(int cap,
> 		   isetset * head,
> 		   itemrec * solRec,
> 		   stype   * minObj){
>   allinfo a;
>   ordstack stacka, stackb;
>   stype cstar, psum = 0, wsum = 0, z, c, ub;
>   partset mid;
>   itemset *s;
>   itype pb, wb;
>   boolean optimal;
>   stype obj = 0;
>   int i, status;
>   ntype k = head->size;
> 
>   a.k        = k;
>   a.n        = 0;
>   a.range    = 0;
>   a.type     = 0;
>   a.capacity = cap;
>   cstar = cap;
>   a.summul   = 0;
>   a.maxmul   = 0;
>   a.antmul   = 0;
>   a.redusets = 0;
>   a.reduitems= 0;
>   a.redukill = 0;
>   a.domikill = 0;
>   *minObj    = -999999;
> 
> #ifndef _MSC_VER
>   starttime();
> #endif
> 
> #if 0
>   {
>      itemset *jm, *j;
>      DEBUG(printf("\nat start\n"));
>      jm = head->lset;
>      for(j = head->fset; j <= jm; j++){
> 	visitems(j);
>      }
>   }
> #endif
> 
> 
>   c = cstar;
>   makestacks(&stacka, &stackb, head);
>   status = partition(&a, head, c, &psum, &wsum, &pb, &wb);
>   DEBUG(printf("\nc: %g, psum: %g, wsum: %g, a.dantzig: %g",
>                c, psum, wsum, a.dantzig));
>   if(status != MCKNAP_RC_OK){
>      freestacks(&stacka, &stackb);
>      return status;
>   }
> 
>   restore(head, psum, wsum);
>   DEBUG(printf("\nafter restore psum: %g, wsum: %g", psum, wsum));
> #ifndef _MSC_VER
>   endtime(&a.timepar);
> #endif
>   if (psum == a.dantzig) {
>     stacka.i->dp = pb; stacka.i->dw = wb; stacka.i->ref = head->fset;
>     stackb.i->dp = pb; stackb.i->dw = wb; stackb.i->ref = head->fset;
>   } else {
>     defineedges(&stacka, &stackb, head);
>   }
> #ifndef _MSC_VER
>   endtime(&a.timesort);
> #endif
> 
>   z = psum-1; ub = a.dantzig;
>   for (i = 1; ; i++) {
>     DEBUG(printf("\n==== loop i: %d", i));
>     initfirst(&mid, head->fset, psum, wsum);
>     for (;;) {
>       reduceset(&mid, stacka.i, stackb.i, &z, c);
>       DEBUG(printf("\n1 - mid.size: %d, z: %g, ub: %g",
>                    mid.size, z, ub));
>       if ((mid.size == 0) || (z == ub)) break;
> 
>       s = stacka.i->ref; if (s == NULL) break;
>       (stacka.i)++; checkinterval(&stacka);
>       if (!s->used) {
> 	reduceitem(&a, s, psum, wsum, pb, wb, z, c);
> 	domiitem(s);
> 	if (s->size > 1) {
> 	  multiply(&a, &mid, s);
> 	  a.antmul++;
> 	  a.summul += mid.size;
> 	  if (mid.size > a.maxmul) a.maxmul = mid.size;
> 	}
> 	s->used = TRUE;
>       }
> 
>       reduceset(&mid, stacka.i, stackb.i, &z, c);
>       DEBUG(printf("\n2 - mid.size: %d, z: %g, ub: %g",
>                    mid.size, z, ub));
>       if ((mid.size == 0) || (z == ub)) break;
> 
>       s = stackb.i->ref; if (s == NULL) break;
>       (stackb.i)--; checkinterval(&stackb);
>       if (!s->used) {
> 	reduceitem(&a, s, psum, wsum, pb, wb, z, c);
> 	domiitem(s);
> 	if (s->size > 1) {
> 	  multiply(&a, &mid, s);
> 	  a.antmul++;
> 	  a.summul += mid.size;
> 	  if (mid.size > a.maxmul) a.maxmul = mid.size;
> 	}
> 	s->used = TRUE;
>       }
>     }
>     if (i == 1) a.zstar = z;
>     optimal = definesol(&a, psum, wsum, &stacka, &stackb, &c, &z, &ub, &obj);
>     pfree(mid.fset);
>     if (optimal) { a.iterates += i; break; }
>     vis(1,"TUR TIL MED c %g, z %g, ub %g\n", c, z, ub);
>     if (i > 10) error("for mange runder");
>   }
> 
>   a.gap = a.dantzig - a.zstar;
>   freestacks(&stacka, &stackb);
> 
> #ifndef _MSC_VER
>   endtime(&a.time);
> #endif
> 
>   checksolution(&a, head, a.zstar, cstar);
>   /*visitems(optsol.list[0].set);
> 
>   //save optimal solution vector
>   //assert(optsol.size == 1);
>   //if(optsol.size != 1){
>   //   printf("\nERROR");
>   //   abort();
>   //}*/
>   
> #if 0
>   for(i=0; i < optsol.size; i++){
>      visitems(optsol.list[i].set);
>   }
>   /*visitems(optsol.list[0].set);*/
>   for(i = 0; i < k; i++){
>      solRec[i] = optsol.list[optsol.size-1].set[i].f;    
>   }
> #endif
> 
> #if 1
>   {
>      itemset *jm, *j;
>      i  = 0;
>      jm = head->lset;
>      for(j = head->fset; j <= jm; j++){
> 	/*visitems(j);*/
> 	solRec[i] = j->f;
> 	i++;
>      }
>   }
> #endif
>   
>     
>   /*sumdata(&a);*/
>   /*freeitems(head);*/
>   *minObj = obj;
>   return MCKNAP_RC_OK;
> }
1581c1826
< 
---
> #if 0
1593c1838
<     printf("Mcknap %d %d %d %d\n", k, n, r, type);
---
>     DEBUG(printf("Mcknap %d %d %d %d\n", k, n, r, type);
1595,1599c1840,1844
<     printf("Mcknap\n");
<     printf("k = "); scanf("%d", &k);
<     printf("n = "); scanf("%d", &n);
<     printf("r = "); scanf("%d", &r);
<     printf("t = "); scanf("%d", &type);
---
>     DEBUG(printf("Mcknap\n");
>     DEBUG(printf("k = "); scanf("%d", &k);
>     DEBUG(printf("n = "); scanf("%d", &n);
>     DEBUG(printf("r = "); scanf("%d", &r);
>     DEBUG(printf("t = "); scanf("%d", &type);
1603c1848
<   fprintf(trace,"\nMCKNAP: k: %d, n: %d, r: %d, type: %d\n", k, n, r, type);
---
>   fprinft(trace,"\nMCKNAP: k: %d, n: %d, r: %d, type: %d\n", k, n, r, type);
1615c1860
<   sumdata(NULL);
---
>   /*sumdata(NULL);*/
1618c1863
< 
---
> #endif
