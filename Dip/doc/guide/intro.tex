Using a high-level modelling language such as AMPL, GAMS, Xpress-MP or OPL Studio enables Operations Research practitioners to express complicated \ac{MILP} problems quickly and (reasonably) easily. Once defined in one of these high-level languages, the \ac{MILP} problem can be solved using one of a number of solvers. However, for many \ac{MILP} problems using solvers ``out of the box'' is only effective for small problem instances (due to the fact that \ac{MILP} problems are NP-hard). Advanced \ac{MILP} techniques are needed for large problem instances and, in many cases, problem-specific techniques need to be included in the solution process.

Both commercial solvers such as CPLEX and open source solvers such as Cbc, Symphony and \acs{DIP} (all from the COIN-OR repository \cite{coin_or}) provide callback functions that allow user-defined routines to be included in the solution framework. However, to make use of the callback functions and develop the user-defined routines, the user must first create their \ac{MILP} problem in a low-level language (C, C++ or Java for Cplex, C or C++ for Cbc, Symphony or \acs{DIP}). While defining their problem, they need to create structures to keep track of appropriate constraints and/or variables for later use in their user-defined routines. For a \ac{MILP} problem of any reasonable size and/or complexity, the problem definition in C/C++/Java is a major undertaking and, thus, a major barrier to the development of customised \ac{MILP} frameworks by both practitioners and researchers.

Given the difficulty of defining a \ac{MILP} problem in a low-level language, another alternative is to return to the high-level mathematical modelling languages (AMPL, GAMS, Xpress-MP, OPL Studio) or their open source equivalents (such as FLOPC++, GAMSlinks and PuLP) to define the \ac{MILP} problem. Then, by carefully constructing an indexing scheme, constraints and/or variables in the high-level language can be identified in the low-level callback functions and advanced \ac{MILP} techniques used. However, implementing the indexing scheme is possibly as difficult as simply using the low-level language to define the \ac{MILP} problem in the first place and so combining high-level and low-level languages does not remove the barrier to solution development.

The purpose of the research presented here is the removal of the barrier that prevents easy experimentation with/customisation of advanced \ac{MILP} solution frameworks. To achieve this aim we need to:
\begin{enumerate}
\item provide an straightforward modelling system so that users can quickly and easily describe their \ac{MILP} problems;
\item enable the callback functions to easily identify constraints and variables in the solution framework.
\end{enumerate}
PuLP already provides a straightforward modelling system for describing \ac{MILP} problems. In our research we extended PuLP so that a \ac{MILP} could be defined and solved using \ac{DIP} \cite{decomp04} within a Python file. We also extended \ac{DIP} so that routines defined within that Python file will be called by the \ac{DIP} callback functions. Variable scope within Python means that these user-defined (Python) routines have complete knowledge of the original problem defined in PuLP. Any extra information required to generate cuts, determine branches or generate columns is provided by the \ac{DIP} callback functions. This ``glue'' between PuLP and \ac{DIP} overcomes the barrier to easy customisation of \ac{DIP} and provides both practitioners and students a straightforward interface for describing problems and customising their solution framework.

The rest of this article is structured as follows. In \scnref{scn:overview} we provide an overview of the interface between PuLP and \ac{DIP}, including a description of the callback functions available in Python from \ac{DIP}. Then, \scnref{scn:define} contains the description and model definition for case studies we will use to demonstrate the effectiveness of Dippy for experimenting with advanced \ac{MILP} techniques. Next, in sections \ref{scn:branch}-\ref{scn:heuristics} we describe how to customise the \ac{DIP} framework to experiment with improvements to the \ac{MILP} solution frameworks available in \ac{DIP}.We conclude in \scnref{scn:concl} where we discuss how this project enhances the ability of researchers to experiment with approaches for solving difficult \ac{MILP} problems.
