We will use the Bin Packing Problem to demonstrate the implementation of customised branching rules, custom cuts, heuristics, and a column generation algorithm.

The solution of the problem determines which, of $m$ bins, to use and also places $n$ items of various sizes into the bins in a way that (in this version) minimises the wasted capacity of the bins.
Each item $j=1, \ldots, n$ has a size $s_j$ and each bin has capacity $C$.
Extensions of this problem arise often in \ac{MILP} in problems including network design and rostering.

The \ac{MILP} formulation of the bin packing problem is straightforward.
The decision variables are
\begin{align*}
x_{ij} &= \begin{cases} 1 & \text{if item $j$ is placed in bin $i$} \\
0 & \text{otherwise} \end{cases} \\
y_i &= \begin{cases} 1 & \text{if bin $i$ is used} \\
0 & \text{otherwise} \end{cases} \\
w_i &= \text{ ``wasted'' capacity in bin $i$}
\end{align*}
and the formulation is
\[
\begin{array}{rr@{\ }ll}
       \min & \displaystyle \sum_{i=1}^m w_i \\
\text{s.t.} & \displaystyle \sum_{i=1}^m x_{ij}           & = 1, j = 1, \ldots, n      & \text{ (each item packed)} \\
            & \displaystyle \sum_{j=1}^n s_j x_{ij} + w_i & = C y_i, i = 1, \ldots, m  & \text{ (aggregate packing for bin $i$)} \\
            & \multicolumn{2}{l}{x_{ij} \leq y_i, i = 1, \ldots, m, j = 1, \ldots, n}  & \text{ (individual packing for bin $i$)} \\[6pt]
            & \multicolumn{3}{l}{x_{ij} \in \{ 0, 1\}, w_i \geq 0, y_i \in \{0, 1\}, i = 1, \ldots, m, j = 1, \ldots, n}
\end{array}
\]

Note that the constraints for the individual packing in a bin are not necessary for defining the solution, but tighten the \ac{MILP} formulation by removing fractional solutions from the solution space. Before looking at the advanced techniques that can be easily implemented using Dippy, we will examine how to formulate the bin packing problem in PuLP and Dippy.

\subsection{Formulating the Bin Packing Problem} \label{sbs:formulate}

Before formulating we need to include the PuLP and Dippy modules into Python
\lstinputlisting[firstnumber=3,linerange=3-21]{../../examples/Dippy/bpp/bin_pack_func.py}
and define a class to hold a bin packing problem's data
\lstinputlisting[firstnumber=25,linerange=25-31]{../../examples/Dippy/bpp/bin_pack_func.py}

The \lstinline{formulate} function is defined with a bin packing problem object as input and creates a \lstinline{DipProblem} (with some display options defined)
\lstinputlisting[firstnumber=33,linerange=33-38]{../../examples/Dippy/bpp/bin_pack_func.py}

Then, using the bin packing problem object's data (i.e., the data defined within \lstinline{bpp}), the decision variables
\lstinputlisting[firstnumber=40,linerange=40-45]{../../examples/Dippy/bpp/bin_pack_func.py}
objective function
\lstinputlisting[firstnumber=47,linerange=47-47]{../../examples/Dippy/bpp/bin_pack_func.py}
\newpage
and constraints are defined
\lstinputlisting[firstnumber=49,linerange=49-59]{../../examples/Dippy/bpp/bin_pack_func.py}

Finally, the bin packing problem object and the decision variables are all ``embedded'' within the \lstinline{DipProblem} object, \lstinline{prob}, and this object is returned (note that the objective function and constraints could also be similarly embedded)
\lstinputlisting[firstnumber=64,linerange=64-71]{../../examples/Dippy/bpp/bin_pack_func.py}

In order to solve the bin packing problem, only the \lstinline{DipProblem} object, \lstinline{prob}, is required (note that no \lstinline{dippyOpts} are specified, so the Dippy defaults are used)
\lstinputlisting[firstnumber=73,linerange={100-101,108-108,115-122}]{../../examples/Dippy/bpp/bin_pack_func.py}

To solve an instance of the bin packing problem, the data needs to be specified and then the problem formulated and solved
\lstinputlisting[firstnumber=3,linerange=3-11]{../../examples/Dippy/bpp/bin_pack_instance.py}
\lstinputlisting[firstnumber=13,linerange=13-21]{../../examples/Dippy/bpp/bin_pack_instance.py}

Solving this bin packing problem instance in Dippy gives the branch-and-bound tree shown in figure \ref{fig:bpp_tree1} (note thet the integer solution found -- indicated in blue \lstinline{S: 5.0} -- bounds all other nodes in the tree) with the final solution packing items 1 and 2 into bin 0 (for a waste of 1), items 3 and 5 into bin 1 (for a waste of 3) and item 4 into bin 3 (for a waste of 1).
\begin{figure}[htp]
\begin{center}
%\includegraphics[bb=0 0 815 496,scale=0.50]{img/bpp_tree1.png}
\includegraphics[scale=0.16]{img/bpp_tree1.eps}
\end{center}
\caption{Branch-and-bound tree for bin packing problem instance.} \label{fig:bpp_tree1}
\end{figure}

\subsection{Adding Customised Branching} \label{sbs:branch}
\input{branch}

\subsection{Adding Customised Cut Generation} \label{sbs:cuts}
\input{cuts}

\subsection{Adding Customised Column Generation} \label{sbs:column}
\input{column}

\newpage\subsection{Adding Customised Heuristics} \label{sbs:heuristics}
\input{heuristics}

\subsection{Combining Techniques} \label{sbs:combine}

\begin{table}[ht]
%\begin{minipage}[c]{\textwidth}
%\begin{small}
\begin{center}
\begin{tabular}[c]{|lll|}
\hline
\textbf{Strategies}																 & \textbf{Time (s)}	& \textbf{Nodes} \\ 
\hline & &\\[-10pt]
Default (branch and cut)                           & 0.26							  & 419 \\
\hline
+ ordering constraints (OC)                        & 0.05 							& 77 \\
+ OC \& advanced branching (AB)                    & 0.01 							& 3 \\
\hline
+ weighted inequalities (WI)                       & 0.34 							& 77 \\
+ WI \& OC                                         & 0.17 							& 20 \\
+ WI \& OC \& AB                                   & 0.06 							& 4 \\
\hline
+ first-fit heuristic (FF) at root node            & 0.28 							& 419 \\
+ FF \& OC                                         & 0.05 							& 77 \\
+ FF \& OC \& AB                                   & 0.01 							& 3 \\
\hline
+ FF \& WI                                         & 0.36 							& 77 \\
+ FF \& WI \& OC                                   & 0.14 							& 17 \\
+ FF \& WI \& OC \& AB                             & 0.05 							& 3 \\
\hline
+ fractional-fit heuristic (RF) at nodes           & 0.28 							& 419 \\
+ RF \& OC                                         & 0.05 							& 77 \\
+ RF \& OC \& AB                                   & 0.01 							& 3 \\
\hline
+ WI \& RF                                         & 0.38 							& 77 \\
+ WI \& RF \& OC                                   & 0.14 							& 17 \\
+ WI \& RF \& OC \& AB                             & 0.05 							& 3 \\
\hline
+ FF \& RF                                         & 0.28 							& 419 \\
+ FF \& RF \& OC                                   & 0.05 							& 77 \\
+ FF \& RF \& OC \& AB                             & 0.01 							& 3 \\
\hline
+ WI \& FF \& RF                                   & 0.38 							& 77 \\
+ WI \& FF \& RF \& OC                             & 0.14 							& 17 \\
+ WI \& FF \& RF \& OC \& AB                       & 0.05 							& 3 \\
\hline
+ column generation (CG)                           & 2.98 							& 37 \\
+ CG \& OC                                         & 2.07 							& 23 \\
+ CG \& OC \& AB                                   & 0.56								& 10 \\
\hline
+ CG \& customised subproblem solver (CS)          & 2.87 							& 37 \\
+ CG \& CS \& OC                                   & 1.95 							& 23 \\
+ CG \& CS \& OC \& AB                             & 0.44 							& 10 \\
\hline
+ CG \& first-fit initial variable generation (FV) & 3.96 							& 45 \\
+ CG \& CS \& FV                                   & 3.72 							& 45 \\
+ CG \& CS \& FV \& OC                             & 1.70 							& 18 \\
+ CG \& CS \& FV \& OC \& AB                       & 0.22 							& 3\\
\hline
+ CG \& one-each initial variable generation (OV)  & 3.40 							& 41 \\
+ CG \& CS \& OV                                   & 3.33 							& 41 \\
+ CG \& CS \& OV \& OC                             & 2.23 							& 24 \\
+ CG \& CS \& OV \& OC \& AB                       & 0.27 							& 3 \\
\hline
\end{tabular} 
\end{center}
%\end{small}
%\end{minipage}
\caption{Experiments for the Capacitated Facility Location Problem} \label{tab:fac_exp}
\end{table}

The techniques and modifications of the solver framework can be combined to improve performance further.
\Tabref{tab:fac_exp} shows that it is possible to quickly and easily test many approaches for a particular problem, including combinations of approaches\footnote{All tests were run using Python 2.7.1 on a Windows~7 machine with an Intel Core~2~Duo T9500@2.60GHz CPU.}.
Looking at the results shows that the heuristics only help when the size of the branch-and-bound tree has been reduced with other approaches, such as ordering constraints and advanced branching.
Approaches for solving this problem that warrant further investigation use column generation, the customised solver and either ordering constraints or the first-fit heuristic to generate initial variables.
Tests with different data showed that the solution time for branch-price-and-cut doesn't increase with problem size as quickly as for branch-and-cut, so the column generation approaches are worth considering for larger problems.
