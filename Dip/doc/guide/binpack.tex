\subsection{The Bin Packing Problem (bin\_pack\_func.py)} \label{sbs:binpack}

The solution of the bin packing problem determines where, amongst $m$ ``bins'', to place $n$ ``items'' of various ``sizes'' in a way that (in this case study) minimises the wasted ``capacity'' of the bins. Each product $j=1, \ldots, n$ has a size $s_j$ and each bin has capacity $C$. Extensions of this problem arise often in \ac{MILP} in problems including network design and rostering.

The \ac{MILP} formulation of the bin packing problem is straightforward. The decision variables are
\begin{align*}
x_{ij} &= \begin{cases} 1 & \text{if item $j$ is placed in bin $i$} \\
0 & \text{otherwise} \end{cases} \\
y_i &= \begin{cases} 1 & \text{if a facility is located at location $i$} \\
0 & \text{otherwise} \end{cases} \\
w_i &= \text{ ``wasted'' capacity at location $i$}
\end{align*}
and the formulation is
\[
\begin{array}{rr@{\ }ll}
       \min & \displaystyle \sum_{i=1}^m w_i \\
\text{s.t.} & \displaystyle \sum_{i=1}^m x_{ij}           & = 1, j = 1, \ldots, n      & \text{ (each product produced)} \\
            & \displaystyle \sum_{j=1}^n r_j x_{ij} + w_i & = C y_i, i = 1, \ldots, m  & \text{ (aggregate capacity at location $i$)} \\
            & \multicolumn{2}{l}{x_{ij} \leq y_i, i = 1, \ldots, m, j = 1, \ldots, n}  & \text{ (disaggregate capacity at location $i$)} \\[6pt]
            & \multicolumn{3}{l}{x_{ij} \in \{ 0, 1\}, w_i \geq 0, y_i \in \{0, 1\}, i = 1, \ldots, m, j = 1, \ldots, n}
\end{array}
\]

Note that the disaggregate capacity constraints are not necessary for defining the solution, but tighten the \ac{MILP} formulation ( i.e., remove factional solutions from the solution space). Using PuLP we can easily define this \ac{MILP} problemm in Dippy. The entire input file is given below with a summary for each fragment.

\begin{enumerate}
\item Load PuLP and Dippy;
\lstinputlisting[linerange=3-20]{../../examples/Dippy/bpp/bin_pack_func.py}

\item Get the problem data from another file. This determines $j=1, \ldots, n$, $i = 1, \ldots, m$, $r_j, j = 1, \ldots, n$ and $C$;
\lstinputlisting[firstnumber=9,linerange=9-10]{C:/COIN/Dip/Dip/examples/Dippy/bpp/bin_pack_func.py}
For {\tt facility\_ex1.py} $n = 5, m = 5, r = (7, 5, 3, 2, 2)^\top$ and $C = 8$.

\item Define the \ac{MILP} problem and the problem variables;
\lstinputlisting[firstnumber=15,linerange=15-24]{../../examples/Dippy/bpp/bin_pack_func.py}

\item Define the objective function;
\lstinputlisting[firstnumber=26,linerange=26-27]{../../examples/Dippy/bpp/bin_pack_func.py}

\item Define the constraints; \lstinputlisting[firstnumber=29,linerange=29-42]{../../examples/Dippy/bpp/bin_pack_func.py}

\item Solve the \ac{MILP} problem using \ac{DIP} using default options except for a user-defined zero tolerance and then display the solution;
\lstinputlisting[firstnumber=235,linerange=235-244]{../../examples/Dippy/bpp/bin_pack_func.py}
\end{enumerate}
Running the preceding Python codes takes 1.17s of CPU time, creates a tree with 375 nodes and gives the following output
\begin{verbatim}
Location  1  produces  [1]
Location  4  produces  [4, 5]
Location  5  produces  [2, 3]
\end{verbatim}

Note that \ac{DIP} uses cuts from the \ac{CGL} \cite{coin_or} by default. We can turn all cuts off by setting the {\tt generateCuts} flag to 0 and turn \ac{CGL} cuts off by setting the {\tt CutCGL} flag to 0. We will use these settings to explore the effect of user-defined cuts in \scnref{scn:cuts}.
